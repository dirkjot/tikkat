import slack
import os
from airtable import Airtable
from pprint import pprint
from datetime import datetime


class objectview(object):
    """Convert dict(or parameters of dict) to object view
    See also:
        - https://goodcode.io/articles/python-dict-object/
        - https://stackoverflow.com/questions/1305532/convert-python-dict-to-object
    >>> o = objectview({'a': 1, 'b': 2})
    >>> o.a, o.b
    (1, 2)
    >>> o = objectview(a=1, b=2)
    >>> o.a, o.b
    (1, 2)
    """

    def __init__(self, *args, **kwargs):
        d = dict(*args, **kwargs)
        self.__dict__ = d


########################


baseid = os.environ.get('AIRTABLE_BASE')
tablename = 'Tickets'
tickets_table = Airtable(baseid, tablename)


# note that the namespacing has changed as of slackclient 2.0
slackclient = slack.WebClient(token=os.environ.get('SLACK_API_TOKEN'))



#######################

# get private channel (aka group) history, see https://api.slack.com/methods/groups.history
# you could do the same with channel history, just a different call..

class FieldUpdate(object):
    title = value = table = record = timestamp = None
    def __init__(self, title, value, table, record, timestamp):
        self.title = title
        self.value = value
        self.table = table
        self.record = record
        self.timestamp = timestamp

    def __str__(self):
        return f"Found {self.title} changed to {self.value} for record {self.record} in {self.table} at ts {self.timestamp}"


def get_airdetails_from_link(slack_title_link):
    "Given a slack title link, extract table name and record name"
    return slack_title_link.split('/')[3:]


def generate_final_states(slackclient, count=100):
    hist = slackclient.groups_history(
        channel='GJV0WJUPJ',  # darkbots group
        count=count) 
    ok = hist.get('ok')
    assert ok is not None

    final_states = ('Completed', 'Rejected')
    AIRTABLE_BOT_ID = 'BJUEU6P60'

    for message in hist.get('messages'):
        if (message['type'] == 'message' and message.get('subtype') == 'bot_message' and
                message['bot_id'] == AIRTABLE_BOT_ID and message.get('attachments') is not None):
            for attachment in message['attachments']:
                for field in attachment['fields']:
                    if field['title'] == 'State' and field['value'] in final_states:
                        # state was updated
                        table, record = get_airdetails_from_link(
                            attachment['title_link'])
                        fup = FieldUpdate(
                            field['title'], field['value'], table, record, message['ts'])
                        yield(fup)


def airtable_update_completion(updategen, tickets_table):
    """
    For each FieldUpdate generated by updategen, fill the
    'completionTime' record in airtable 'tickets_table' with the timestamp 
    in the FieldUpdate
    """
    for upd in updategen:
        assert upd.table == 'tblA4zbHiw2Lqyvzo'
        record = tickets_table.get(upd.record)
        assert record['id'] == upd.record
        assert record['fields'].get(upd.title) == upd.value
        if record['fields'].get('Completion') is None:
            datestring = datetime.utcfromtimestamp(int(float(upd.timestamp))).strftime('%Y-%m-%d')
            record = tickets_table.update(upd.record, {'Completion': datestring})
            print(upd)


if __name__ == "__main__":
    airtable_update_completion(
        generate_final_states(slackclient, 100), 
        tickets_table)
